"use strict";

Liferay.Loader.define("@frontend-taglib-clay$clayui/tooltip@3.4.0/lib/Tooltip", ['module', 'exports', 'require', 'frontend-taglib-clay$classnames', 'frontend-js-react-web$react'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = exports.ALIGN_POSITIONS = void 0;

    var _classnames = _interopRequireDefault(require("frontend-taglib-clay$classnames"));

    var _react = _interopRequireDefault(require("frontend-js-react-web$react"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _extends() {
      _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };return _extends.apply(this, arguments);
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];
        }
      }return target;
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
      }return target;
    }

    var ALIGN_POSITIONS = ['top', 'top-left', 'top-right', 'bottom', 'bottom-left', 'bottom-right', 'left', 'right'];
    exports.ALIGN_POSITIONS = ALIGN_POSITIONS;

    var ClayTooltip = /*#__PURE__*/_react.default.forwardRef(function (_ref, ref) {
      var _ref$alignPosition = _ref.alignPosition,
          alignPosition = _ref$alignPosition === void 0 ? 'bottom' : _ref$alignPosition,
          children = _ref.children,
          className = _ref.className,
          show = _ref.show,
          otherProps = _objectWithoutProperties(_ref, ["alignPosition", "children", "className", "show"]);

      return (/*#__PURE__*/_react.default.createElement("div", _extends({
          className: (0, _classnames.default)(className, 'tooltip', "clay-tooltip-".concat(alignPosition), {
            show: show
          }),
          role: "tooltip"
        }, otherProps, {
          ref: ref
        }), /*#__PURE__*/_react.default.createElement("div", {
          className: "arrow"
        }), /*#__PURE__*/_react.default.createElement("div", {
          className: "tooltip-inner"
        }, children))
      );
    });

    ClayTooltip.displayName = 'ClayTooltip';
    var _default = ClayTooltip;
    exports.default = _default;
  }
});
//# sourceMappingURL=Tooltip.js.map
'use strict';

Liferay.Loader.define('frontend-taglib-clay$dom-align@1.10.4/dist-node/index', ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, '__esModule', { value: true });

    var vendorPrefix;
    var jsCssMap = {
      Webkit: '-webkit-',
      Moz: '-moz-',
      // IE did it wrong again ...
      ms: '-ms-',
      O: '-o-'
    };

    function getVendorPrefix() {
      if (vendorPrefix !== undefined) {
        return vendorPrefix;
      }

      vendorPrefix = '';
      var style = document.createElement('p').style;


      for (var key in jsCssMap) {
        if (key + 'Transform' in style) {
          vendorPrefix = key;
        }
      }

      return vendorPrefix;
    }

    function getTransitionName() {
      return getVendorPrefix() ? "".concat(getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
    }

    function getTransformName() {
      return getVendorPrefix() ? "".concat(getVendorPrefix(), "Transform") : 'transform';
    }
    function setTransitionProperty(node, value) {
      var name = getTransitionName();

      if (name) {
        node.style[name] = value;

        if (name !== 'transitionProperty') {
          node.style.transitionProperty = value;
        }
      }
    }

    function setTransform(node, value) {
      var name = getTransformName();

      if (name) {
        node.style[name] = value;

        if (name !== 'transform') {
          node.style.transform = value;
        }
      }
    }

    function getTransitionProperty(node) {
      return node.style.transitionProperty || node.style[getTransitionName()];
    }
    function getTransformXY(node) {
      var style = window.getComputedStyle(node, null);
      var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

      if (transform && transform !== 'none') {
        var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
        return {
          x: parseFloat(matrix[12] || matrix[4], 0),
          y: parseFloat(matrix[13] || matrix[5], 0)
        };
      }

      return {
        x: 0,
        y: 0
      };
    }
    var matrix2d = /matrix\((.*)\)/;
    var matrix3d = /matrix3d\((.*)\)/;
    function setTransformXY(node, xy) {
      var style = window.getComputedStyle(node, null);
      var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

      if (transform && transform !== 'none') {
        var arr;
        var match2d = transform.match(matrix2d);

        if (match2d) {
          match2d = match2d[1];
          arr = match2d.split(',').map(function (item) {
            return parseFloat(item, 10);
          });
          arr[4] = xy.x;
          arr[5] = xy.y;
          setTransform(node, "matrix(".concat(arr.join(','), ")"));
        } else {
          var match3d = transform.match(matrix3d)[1];
          arr = match3d.split(',').map(function (item) {
            return parseFloat(item, 10);
          });
          arr[12] = xy.x;
          arr[13] = xy.y;
          setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
        }
      } else {
        setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
      }
    }

    function _typeof(obj) {
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }

      return _typeof(obj);
    }
    var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
    var getComputedStyleX; // https://stackoverflow.com/a/3485654/3040605

    function forceRelayout(elem) {
      var originalStyle = elem.style.display;
      elem.style.display = 'none';
      elem.offsetHeight; // eslint-disable-line

      elem.style.display = originalStyle;
    }

    function css(el, name, v) {
      var value = v;

      if (_typeof(name) === 'object') {
        for (var i in name) {
          if (name.hasOwnProperty(i)) {
            css(el, i, name[i]);
          }
        }

        return undefined;
      }

      if (typeof value !== 'undefined') {
        if (typeof value === 'number') {
          value = "".concat(value, "px");
        }

        el.style[name] = value;
        return undefined;
      }

      return getComputedStyleX(el, name);
    }

    function getClientPosition(elem) {
      var box;
      var x;
      var y;
      var doc = elem.ownerDocument;
      var body = doc.body;
      var docElem = doc && doc.documentElement; // 根据 GBS 最新数据，A-Grade Browsers 都已支持 getBoundingClientRect 方法，不用再考虑传统的实现方式

      box = elem.getBoundingClientRect(); // 注：jQuery 还考虑减去 docElem.clientLeft/clientTop
      // 但测试发现，这样反而会导致当 html 和 body 有边距/边框样式时，获取的值不正确
      // 此外，ie6 会忽略 html 的 margin 值，幸运地是没有谁会去设置 html 的 margin

      x = box.left;
      y = box.top; // In IE, most of the time, 2 extra pixels are added to the top and left
      // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
      // IE6 standards mode, this border can be overridden by setting the
      // document element's border to zero -- thus, we cannot rely on the
      // offset always being 2 pixels.
      // In quirks mode, the offset can be determined by querying the body's
      // clientLeft/clientTop, but in standards mode, it is found by querying
      // the document element's clientLeft/clientTop.  Since we already called
      // getClientBoundingRect we have already forced a reflow, so it is not
      // too expensive just to query them all.
      // ie 下应该减去窗口的边框吧，毕竟默认 absolute 都是相对窗口定位的
      // 窗口边框标准是设 documentElement ,quirks 时设置 body
      // 最好禁止在 body 和 html 上边框 ，但 ie < 9 html 默认有 2px ，减去
      // 但是非 ie 不可能设置窗口边框，body html 也不是窗口 ,ie 可以通过 html,body 设置
      // 标准 ie 下 docElem.clientTop 就是 border-top
      // ie7 html 即窗口边框改变不了。永远为 2
      // 但标准 firefox/chrome/ie9 下 docElem.clientTop 是窗口边框，即使设了 border-top 也为 0

      x -= docElem.clientLeft || body.clientLeft || 0;
      y -= docElem.clientTop || body.clientTop || 0;
      return {
        left: x,
        top: y
      };
    }

    function getScroll(w, top) {
      var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
      var method = "scroll".concat(top ? 'Top' : 'Left');

      if (typeof ret !== 'number') {
        var d = w.document; // ie6,7,8 standard mode

        ret = d.documentElement[method];

        if (typeof ret !== 'number') {
          // quirks mode
          ret = d.body[method];
        }
      }

      return ret;
    }

    function getScrollLeft(w) {
      return getScroll(w);
    }

    function getScrollTop(w) {
      return getScroll(w, true);
    }

    function getOffset(el) {
      var pos = getClientPosition(el);
      var doc = el.ownerDocument;
      var w = doc.defaultView || doc.parentWindow;
      pos.left += getScrollLeft(w);
      pos.top += getScrollTop(w);
      return pos;
    }
    /**
     * A crude way of determining if an object is a window
     * @member util
     */

    function isWindow(obj) {
      // must use == for ie8

      /* eslint eqeqeq:0 */
      return obj !== null && obj !== undefined && obj == obj.window;
    }

    function getDocument(node) {
      if (isWindow(node)) {
        return node.document;
      }

      if (node.nodeType === 9) {
        return node;
      }

      return node.ownerDocument;
    }

    function _getComputedStyle(elem, name, cs) {
      var computedStyle = cs;
      var val = '';
      var d = getDocument(elem);
      computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null); // https://github.com/kissyteam/kissy/issues/61

      if (computedStyle) {
        val = computedStyle.getPropertyValue(name) || computedStyle[name];
      }

      return val;
    }

    var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');

    var RE_POS = /^(top|right|bottom|left)$/;
    var CURRENT_STYLE = 'currentStyle';
    var RUNTIME_STYLE = 'runtimeStyle';
    var LEFT = 'left';
    var PX = 'px';

    function _getComputedStyleIE(elem, name) {
      // currentStyle maybe null
      // http://msdn.microsoft.com/en-us/library/ms535231.aspx
      var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name]; // 当 width/height 设置为百分比时，通过 pixelLeft 方式转换的 width/height 值
      // 一开始就处理了! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook 解决@2011-08-19
      // 在 ie 下不对，需要直接用 offset 方式
      // borderWidth 等值也有问题，但考虑到 borderWidth 设为百分比的概率很小，这里就不考虑了
      // From the awesome hack by Dean Edwards
      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
      // If we're not dealing with a regular pixel number
      // but a number that has a weird ending, we need to convert it to pixels
      // exclude left right for relativity

      if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
        // Remember the original values
        var style = elem.style;
        var left = style[LEFT];
        var rsLeft = elem[RUNTIME_STYLE][LEFT]; // prevent flashing of content

        elem[RUNTIME_STYLE][LEFT] = elem[CURRENT_STYLE][LEFT]; // Put in the new values to get a computed value out

        style[LEFT] = name === 'fontSize' ? '1em' : ret || 0;
        ret = style.pixelLeft + PX; // Revert the changed values

        style[LEFT] = left;
        elem[RUNTIME_STYLE][LEFT] = rsLeft;
      }

      return ret === '' ? 'auto' : ret;
    }

    if (typeof window !== 'undefined') {
      getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
    }

    function getOffsetDirection(dir, option) {
      if (dir === 'left') {
        return option.useCssRight ? 'right' : dir;
      }

      return option.useCssBottom ? 'bottom' : dir;
    }

    function oppositeOffsetDirection(dir) {
      if (dir === 'left') {
        return 'right';
      } else if (dir === 'right') {
        return 'left';
      } else if (dir === 'top') {
        return 'bottom';
      } else if (dir === 'bottom') {
        return 'top';
      }
    } // 设置 elem 相对 elem.ownerDocument 的坐标


    function setLeftTop(elem, offset, option) {
      // set position first, in-case top/left are set even on static elem
      if (css(elem, 'position') === 'static') {
        elem.style.position = 'relative';
      }

      var presetH = -999;
      var presetV = -999;
      var horizontalProperty = getOffsetDirection('left', option);
      var verticalProperty = getOffsetDirection('top', option);
      var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
      var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

      if (horizontalProperty !== 'left') {
        presetH = 999;
      }

      if (verticalProperty !== 'top') {
        presetV = 999;
      }

      var originalTransition = '';
      var originalOffset = getOffset(elem);

      if ('left' in offset || 'top' in offset) {
        originalTransition = getTransitionProperty(elem) || '';
        setTransitionProperty(elem, 'none');
      }

      if ('left' in offset) {
        elem.style[oppositeHorizontalProperty] = '';
        elem.style[horizontalProperty] = "".concat(presetH, "px");
      }

      if ('top' in offset) {
        elem.style[oppositeVerticalProperty] = '';
        elem.style[verticalProperty] = "".concat(presetV, "px");
      } // force relayout


      forceRelayout(elem);
      var old = getOffset(elem);
      var originalStyle = {};

      for (var key in offset) {
        if (offset.hasOwnProperty(key)) {
          var dir = getOffsetDirection(key, option);
          var preset = key === 'left' ? presetH : presetV;
          var off = originalOffset[key] - old[key];

          if (dir === key) {
            originalStyle[dir] = preset + off;
          } else {
            originalStyle[dir] = preset - off;
          }
        }
      }

      css(elem, originalStyle); // force relayout

      forceRelayout(elem);

      if ('left' in offset || 'top' in offset) {
        setTransitionProperty(elem, originalTransition);
      }

      var ret = {};

      for (var _key in offset) {
        if (offset.hasOwnProperty(_key)) {
          var _dir = getOffsetDirection(_key, option);

          var _off = offset[_key] - originalOffset[_key];

          if (_key === _dir) {
            ret[_dir] = originalStyle[_dir] + _off;
          } else {
            ret[_dir] = originalStyle[_dir] - _off;
          }
        }
      }

      css(elem, ret);
    }

    function setTransform$1(elem, offset) {
      var originalOffset = getOffset(elem);
      var originalXY = getTransformXY(elem);
      var resultXY = {
        x: originalXY.x,
        y: originalXY.y
      };

      if ('left' in offset) {
        resultXY.x = originalXY.x + offset.left - originalOffset.left;
      }

      if ('top' in offset) {
        resultXY.y = originalXY.y + offset.top - originalOffset.top;
      }

      setTransformXY(elem, resultXY);
    }

    function setOffset(elem, offset, option) {
      if (option.ignoreShake) {
        var oriOffset = getOffset(elem);
        var oLeft = oriOffset.left.toFixed(0);
        var oTop = oriOffset.top.toFixed(0);
        var tLeft = offset.left.toFixed(0);
        var tTop = offset.top.toFixed(0);

        if (oLeft === tLeft && oTop === tTop) {
          return;
        }
      }

      if (option.useCssRight || option.useCssBottom) {
        setLeftTop(elem, offset, option);
      } else if (option.useCssTransform && getTransformName() in document.body.style) {
        setTransform$1(elem, offset);
      } else {
        setLeftTop(elem, offset, option);
      }
    }

    function each(arr, fn) {
      for (var i = 0; i < arr.length; i++) {
        fn(arr[i]);
      }
    }

    function isBorderBoxFn(elem) {
      return getComputedStyleX(elem, 'boxSizing') === 'border-box';
    }

    var BOX_MODELS = ['margin', 'border', 'padding'];
    var CONTENT_INDEX = -1;
    var PADDING_INDEX = 2;
    var BORDER_INDEX = 1;
    var MARGIN_INDEX = 0;

    function swap(elem, options, callback) {
      var old = {};
      var style = elem.style;
      // Remember the old values, and insert the new ones

      for (var name in options) {
        if (options.hasOwnProperty(name)) {
          old[name] = style[name];
          style[name] = options[name];
        }
      }

      callback.call(elem); // Revert the old values

      for (name in options) {
        if (options.hasOwnProperty(name)) {
          style[name] = old[name];
        }
      }
    }

    function getPBMWidth(elem, props, which) {
      var value = 0;
      var prop;
      var j;
      var i;

      for (j = 0; j < props.length; j++) {
        prop = props[j];

        if (prop) {
          for (i = 0; i < which.length; i++) {
            var cssProp = void 0;

            if (prop === 'border') {
              cssProp = "".concat(prop).concat(which[i], "Width");
            } else {
              cssProp = prop + which[i];
            }

            value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
          }
        }
      }

      return value;
    }

    var domUtils = {
      getParent: function getParent(element) {
        var parent = element;

        do {
          if (parent.nodeType === 11 && parent.host) {
            parent = parent.host;
          } else {
            parent = parent.parentNode;
          }
        } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);

        return parent;
      }
    };
    each(['Width', 'Height'], function (name) {
      domUtils["doc".concat(name)] = function (refWin) {
        var d = refWin.document;
        return Math.max( // firefox chrome documentElement.scrollHeight< body.scrollHeight
        // ie standard mode : documentElement.scrollHeight> body.scrollHeight
        d.documentElement["scroll".concat(name)], // quirks : documentElement.scrollHeight 最大等于可视窗口多一点？
        d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
      };

      domUtils["viewport".concat(name)] = function (win) {
        // pc browser includes scrollbar in window.innerWidth
        var prop = "client".concat(name);
        var doc = win.document;
        var body = doc.body;
        var documentElement = doc.documentElement;
        var documentElementProp = documentElement[prop]; // 标准模式取 documentElement
        // backcompat 取 body

        return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
      };
    });
    /*
     得到元素的大小信息
     @param elem
     @param name
     @param {String} [extra]  'padding' : (css width) + padding
     'border' : (css width) + padding + border
     'margin' : (css width) + padding + border + margin
     */

    function getWH(elem, name, ex) {
      var extra = ex;

      if (isWindow(elem)) {
        return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
      } else if (elem.nodeType === 9) {
        return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
      }

      var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
      var borderBoxValue = name === 'width' ? elem.getBoundingClientRect().width : elem.getBoundingClientRect().height;
      getComputedStyleX(elem);

      var isBorderBox = isBorderBoxFn(elem);
      var cssBoxValue = 0;

      if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
        borderBoxValue = undefined; // Fall back to computed then un computed css if necessary

        cssBoxValue = getComputedStyleX(elem, name);

        if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
          cssBoxValue = elem.style[name] || 0;
        } // Normalize '', auto, and prepare for extra


        cssBoxValue = parseFloat(cssBoxValue) || 0;
      }

      if (extra === undefined) {
        extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
      }

      var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
      var val = borderBoxValue || cssBoxValue;

      if (extra === CONTENT_INDEX) {
        if (borderBoxValueOrIsBorderBox) {
          return val - getPBMWidth(elem, ['border', 'padding'], which);
        }

        return cssBoxValue;
      } else if (borderBoxValueOrIsBorderBox) {
        if (extra === BORDER_INDEX) {
          return val;
        }

        return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
      }

      return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
    }

    var cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }; // fix #119 : https://github.com/kissyteam/kissy/issues/119

    function getWHIgnoreDisplay() {
      for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var val;
      var elem = args[0]; // in case elem is window
      // elem.offsetWidth === undefined

      if (elem.offsetWidth !== 0) {
        val = getWH.apply(undefined, args);
      } else {
        swap(elem, cssShow, function () {
          val = getWH.apply(undefined, args);
        });
      }

      return val;
    }

    each(['width', 'height'], function (name) {
      var first = name.charAt(0).toUpperCase() + name.slice(1);

      domUtils["outer".concat(first)] = function (el, includeMargin) {
        return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
      };

      var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

      domUtils[name] = function (elem, v) {
        var val = v;

        if (val !== undefined) {
          if (elem) {
            getComputedStyleX(elem);

            var isBorderBox = isBorderBoxFn(elem);

            if (isBorderBox) {
              val += getPBMWidth(elem, ['padding', 'border'], which);
            }

            return css(elem, name, val);
          }

          return undefined;
        }

        return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
      };
    });

    function mix(to, from) {
      for (var i in from) {
        if (from.hasOwnProperty(i)) {
          to[i] = from[i];
        }
      }

      return to;
    }

    var utils = {
      getWindow: function getWindow(node) {
        if (node && node.document && node.setTimeout) {
          return node;
        }

        var doc = node.ownerDocument || node;
        return doc.defaultView || doc.parentWindow;
      },
      getDocument: getDocument,
      offset: function offset(el, value, option) {
        if (typeof value !== 'undefined') {
          setOffset(el, value, option || {});
        } else {
          return getOffset(el);
        }
      },
      isWindow: isWindow,
      each: each,
      css: css,
      clone: function clone(obj) {
        var ret = {};

        for (var i in obj) {
          if (obj.hasOwnProperty(i)) {
            ret[i] = obj[i];
          }
        }

        var overflow = obj.overflow;

        if (overflow) {
          for (i in obj) {
            if (obj.hasOwnProperty(i)) {
              ret.overflow[i] = obj.overflow[i];
            }
          }
        }

        return ret;
      },
      mix: mix,
      getWindowScrollLeft: function getWindowScrollLeft(w) {
        return getScrollLeft(w);
      },
      getWindowScrollTop: function getWindowScrollTop(w) {
        return getScrollTop(w);
      },
      merge: function merge() {
        var ret = {};

        for (var i = 0; i < arguments.length; i++) {
          utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
        }

        return ret;
      },
      viewportWidth: 0,
      viewportHeight: 0
    };
    mix(utils, domUtils);

    /**
     * 得到会导致元素显示不全的祖先元素
     */

    var getParent = utils.getParent;

    function getOffsetParent(element) {
      if (utils.isWindow(element) || element.nodeType === 9) {
        return null;
      } // ie 这个也不是完全可行

      /*
       <div style="width: 50px;height: 100px;overflow: hidden">
       <div style="width: 50px;height: 100px;position: relative;" id="d6">
       元素 6 高 100px 宽 50px<br/>
       </div>
       </div>
       */
      // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
      //  In other browsers it only includes elements with position absolute, relative or
      // fixed, not elements with overflow set to auto or scroll.
      //        if (UA.ie && ieMode < 8) {
      //            return element.offsetParent;
      //        }
      // 统一的 offsetParent 方法


      var doc = utils.getDocument(element);
      var body = doc.body;
      var parent;
      var positionStyle = utils.css(element, 'position');
      var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

      if (!skipStatic) {
        return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
      }

      for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
        positionStyle = utils.css(parent, 'position');

        if (positionStyle !== 'static') {
          return parent;
        }
      }

      return null;
    }

    var getParent$1 = utils.getParent;
    function isAncestorFixed(element) {
      if (utils.isWindow(element) || element.nodeType === 9) {
        return false;
      }

      var doc = utils.getDocument(element);
      var body = doc.body;
      var parent = null;

      for (parent = getParent$1(element); parent && parent !== body; parent = getParent$1(parent)) {
        var positionStyle = utils.css(parent, 'position');

        if (positionStyle === 'fixed') {
          return true;
        }
      }

      return false;
    }

    /**
     * 获得元素的显示部分的区域
     */

    function getVisibleRectForElement(element) {
      var visibleRect = {
        left: 0,
        right: Infinity,
        top: 0,
        bottom: Infinity
      };
      var el = getOffsetParent(element);
      var doc = utils.getDocument(element);
      var win = doc.defaultView || doc.parentWindow;
      var body = doc.body;
      var documentElement = doc.documentElement; // Determine the size of the visible rect by climbing the dom accounting for
      // all scrollable containers.

      while (el) {
        // clientWidth is zero for inline block elements in ie.
        if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
        // viewport. In some browsers, el.offsetParent may be
        // document.documentElement, so check for that too.
        el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {
          var pos = utils.offset(el); // add border

          pos.left += el.clientLeft;
          pos.top += el.clientTop;
          visibleRect.top = Math.max(visibleRect.top, pos.top);
          visibleRect.right = Math.min(visibleRect.right, // consider area without scrollBar
          pos.left + el.clientWidth);
          visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
          visibleRect.left = Math.max(visibleRect.left, pos.left);
        } else if (el === body || el === documentElement) {
          break;
        }

        el = getOffsetParent(el);
      } // Set element position to fixed
      // make sure absolute element itself don't affect it's visible area
      // https://github.com/ant-design/ant-design/issues/7601


      var originalPosition = null;

      if (!utils.isWindow(element) && element.nodeType !== 9) {
        originalPosition = element.style.position;
        var position = utils.css(element, 'position');

        if (position === 'absolute') {
          element.style.position = 'fixed';
        }
      }

      var scrollX = utils.getWindowScrollLeft(win);
      var scrollY = utils.getWindowScrollTop(win);
      var viewportWidth = utils.viewportWidth(win);
      var viewportHeight = utils.viewportHeight(win);
      var documentWidth = documentElement.scrollWidth;
      var documentHeight = documentElement.scrollHeight; // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
      // We should cut this ourself.

      var bodyStyle = window.getComputedStyle(body);

      if (bodyStyle.overflowX === 'hidden') {
        documentWidth = win.innerWidth;
      }

      if (bodyStyle.overflowY === 'hidden') {
        documentHeight = win.innerHeight;
      } // Reset element position after calculate the visible area


      if (element.style) {
        element.style.position = originalPosition;
      }

      if (isAncestorFixed(element)) {
        // Clip by viewport's size.
        visibleRect.left = Math.max(visibleRect.left, scrollX);
        visibleRect.top = Math.max(visibleRect.top, scrollY);
        visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
        visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
      } else {
        // Clip by document's size.
        var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
        visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
        var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
        visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
      }

      return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
    }

    function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
      var pos = utils.clone(elFuturePos);
      var size = {
        width: elRegion.width,
        height: elRegion.height
      };

      if (overflow.adjustX && pos.left < visibleRect.left) {
        pos.left = visibleRect.left;
      } // Left edge inside and right edge outside viewport, try to resize it.


      if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
        size.width -= pos.left + size.width - visibleRect.right;
      } // Right edge outside viewport, try to move it.


      if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
        // 保证左边界和可视区域左边界对齐
        pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
      } // Top edge outside viewport, try to move it.


      if (overflow.adjustY && pos.top < visibleRect.top) {
        pos.top = visibleRect.top;
      } // Top edge inside and bottom edge outside viewport, try to resize it.


      if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
        size.height -= pos.top + size.height - visibleRect.bottom;
      } // Bottom edge outside viewport, try to move it.


      if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
        // 保证上边界和可视区域上边界对齐
        pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
      }

      return utils.mix(pos, size);
    }

    function getRegion(node) {
      var offset;
      var w;
      var h;

      if (!utils.isWindow(node) && node.nodeType !== 9) {
        offset = utils.offset(node);
        w = utils.outerWidth(node);
        h = utils.outerHeight(node);
      } else {
        var win = utils.getWindow(node);
        offset = {
          left: utils.getWindowScrollLeft(win),
          top: utils.getWindowScrollTop(win)
        };
        w = utils.viewportWidth(win);
        h = utils.viewportHeight(win);
      }

      offset.width = w;
      offset.height = h;
      return offset;
    }

    /**
     * 获取 node 上的 align 对齐点 相对于页面的坐标
     */
    function getAlignOffset(region, align) {
      var V = align.charAt(0);
      var H = align.charAt(1);
      var w = region.width;
      var h = region.height;
      var x = region.left;
      var y = region.top;

      if (V === 'c') {
        y += h / 2;
      } else if (V === 'b') {
        y += h;
      }

      if (H === 'c') {
        x += w / 2;
      } else if (H === 'r') {
        x += w;
      }

      return {
        left: x,
        top: y
      };
    }

    function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
      var p1 = getAlignOffset(refNodeRegion, points[1]);
      var p2 = getAlignOffset(elRegion, points[0]);
      var diff = [p2.left - p1.left, p2.top - p1.top];
      return {
        left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
        top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
      };
    }

    /**
     * align dom node flexibly
     * @author yiminghe@gmail.com
     */

    function isFailX(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
    }

    function isFailY(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
    }

    function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
    }

    function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
      return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
    }

    function flip(points, reg, map) {
      var ret = [];
      utils.each(points, function (p) {
        ret.push(p.replace(reg, function (m) {
          return map[m];
        }));
      });
      return ret;
    }

    function flipOffset(offset, index) {
      offset[index] = -offset[index];
      return offset;
    }

    function convertOffset(str, offsetLen) {
      var n;

      if (/%$/.test(str)) {
        n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
      } else {
        n = parseInt(str, 10);
      }

      return n || 0;
    }

    function normalizeOffset(offset, el) {
      offset[0] = convertOffset(offset[0], el.width);
      offset[1] = convertOffset(offset[1], el.height);
    }
    /**
     * @param el
     * @param tgtRegion 参照节点所占的区域: { left, top, width, height }
     * @param align
     */

    function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
      var points = align.points;
      var offset = align.offset || [0, 0];
      var targetOffset = align.targetOffset || [0, 0];
      var overflow = align.overflow;
      var source = align.source || el;
      offset = [].concat(offset);
      targetOffset = [].concat(targetOffset);
      overflow = overflow || {};
      var newOverflowCfg = {};
      var fail = 0; // 当前节点可以被放置的显示区域

      var visibleRect = getVisibleRectForElement(source); // 当前节点所占的区域, left/top/width/height

      var elRegion = getRegion(source); // 将 offset 转换成数值，支持百分比

      normalizeOffset(offset, elRegion);
      normalizeOffset(targetOffset, tgtRegion); // 当前节点将要被放置的位置

      var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset); // 当前节点将要所处的区域

      var newElRegion = utils.merge(elRegion, elFuturePos); // 如果可视区域不能完全放置当前节点时允许调整

      if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
        if (overflow.adjustX) {
          // 如果横向不能放下
          if (isFailX(elFuturePos, elRegion, visibleRect)) {
            // 对齐位置反下
            var newPoints = flip(points, /[lr]/gi, {
              l: 'r',
              r: 'l'
            }); // 偏移量也反下

            var newOffset = flipOffset(offset, 0);
            var newTargetOffset = flipOffset(targetOffset, 0);
            var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);

            if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
              fail = 1;
              points = newPoints;
              offset = newOffset;
              targetOffset = newTargetOffset;
            }
          }
        }

        if (overflow.adjustY) {
          // 如果纵向不能放下
          if (isFailY(elFuturePos, elRegion, visibleRect)) {
            // 对齐位置反下
            var _newPoints = flip(points, /[tb]/gi, {
              t: 'b',
              b: 't'
            }); // 偏移量也反下


            var _newOffset = flipOffset(offset, 1);

            var _newTargetOffset = flipOffset(targetOffset, 1);

            var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);

            if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
              fail = 1;
              points = _newPoints;
              offset = _newOffset;
              targetOffset = _newTargetOffset;
            }
          }
        } // 如果失败，重新计算当前节点将要被放置的位置


        if (fail) {
          elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
          utils.mix(newElRegion, elFuturePos);
        }

        var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
        var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect); // 检查反下后的位置是否可以放下了，如果仍然放不下：
        // 1. 复原修改过的定位参数

        if (isStillFailX || isStillFailY) {
          points = align.points;
          offset = align.offset || [0, 0];
          targetOffset = align.targetOffset || [0, 0];
        } // 2. 只有指定了可以调整当前方向才调整


        newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
        newOverflowCfg.adjustY = overflow.adjustY && isStillFailY; // 确实要调整，甚至可能会调整高度宽度

        if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
          newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
        }
      } // need judge to in case set fixed with in css on height auto element


      if (newElRegion.width !== elRegion.width) {
        utils.css(source, 'width', utils.width(source) + newElRegion.width - elRegion.width);
      }

      if (newElRegion.height !== elRegion.height) {
        utils.css(source, 'height', utils.height(source) + newElRegion.height - elRegion.height);
      } // https://github.com/kissyteam/kissy/issues/190
      // 相对于屏幕位置没变，而 left/top 变了
      // 例如 <div 'relative'><el absolute></div>


      utils.offset(source, {
        left: newElRegion.left,
        top: newElRegion.top
      }, {
        useCssRight: align.useCssRight,
        useCssBottom: align.useCssBottom,
        useCssTransform: align.useCssTransform,
        ignoreShake: align.ignoreShake
      });
      return {
        points: points,
        offset: offset,
        targetOffset: targetOffset,
        overflow: newOverflowCfg
      };
    }
    /**
     *  2012-04-26 yiminghe@gmail.com
     *   - 优化智能对齐算法
     *   - 慎用 resizeXX
     *
     *  2011-07-13 yiminghe@gmail.com note:
     *   - 增加智能对齐，以及大小调整选项
     **/

    function isOutOfVisibleRect(target) {
      var visibleRect = getVisibleRectForElement(target);
      var targetRegion = getRegion(target);
      return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
    }

    function alignElement(el, refNode, align) {
      var target = align.target || refNode;
      var refNodeRegion = getRegion(target);
      var isTargetNotOutOfVisible = !isOutOfVisibleRect(target);
      return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
    }

    alignElement.__getOffsetParent = getOffsetParent;
    alignElement.__getVisibleRectForElement = getVisibleRectForElement;

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);

      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }

      return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};

        if (i % 2) {
          ownKeys(source, true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(source).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }

      return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }
    /**
     * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
     * If client position provided, will internal convert to page position.
     */

    function alignPoint(el, tgtPoint, align) {
      var pageX;
      var pageY;
      var doc = utils.getDocument(el);
      var win = doc.defaultView || doc.parentWindow;
      var scrollX = utils.getWindowScrollLeft(win);
      var scrollY = utils.getWindowScrollTop(win);
      var viewportWidth = utils.viewportWidth(win);
      var viewportHeight = utils.viewportHeight(win);

      if ('pageX' in tgtPoint) {
        pageX = tgtPoint.pageX;
      } else {
        pageX = scrollX + tgtPoint.clientX;
      }

      if ('pageY' in tgtPoint) {
        pageY = tgtPoint.pageY;
      } else {
        pageY = scrollY + tgtPoint.clientY;
      }

      var tgtRegion = {
        left: pageX,
        top: pageY,
        width: 0,
        height: 0
      };
      var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight; // Provide default target point

      var points = [align.points[0], 'cc'];
      return doAlign(el, tgtRegion, _objectSpread({}, align, {
        points: points
      }), pointInView);
    }

    exports.alignElement = alignElement;
    exports.alignPoint = alignPoint;
    exports.default = alignElement;
    //# sourceMappingURL=index.js.map
  }
});
//# sourceMappingURL=index.js.map
"use strict";

Liferay.Loader.define("@frontend-taglib-clay$clayui/tooltip@3.4.0/lib/TooltipProvider", ['module', 'exports', 'require', '@frontend-taglib-clay$clayui/shared', 'frontend-taglib-clay$dom-align', 'frontend-js-react-web$react', 'frontend-taglib-clay$warning', './Tooltip'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }return _typeof(obj);
    }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _shared = require("@frontend-taglib-clay$clayui/shared");

    var _domAlign = _interopRequireDefault(require("frontend-taglib-clay$dom-align"));

    var _react = _interopRequireWildcard(require("frontend-js-react-web$react"));

    var _warning = _interopRequireDefault(require("frontend-taglib-clay$warning"));

    var _Tooltip = _interopRequireDefault(require("./Tooltip"));

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
      };return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {
        return cache.get(obj);
      }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }newObj.default = obj;if (cache) {
        cache.set(obj, newObj);
      }return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;if (typeof o === "string") return _arrayLikeToArray(o, minLen);var n = Object.prototype.toString.call(o).slice(8, -1);if (n === "Object" && o.constructor) n = o.constructor.name;if (n === "Map" || n === "Set") return Array.from(o);if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
    }

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }return arr2;
    }

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });keys.push.apply(keys, symbols);
      }return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};var target = _objectWithoutPropertiesLoose(source, excluded);var key, i;if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];if (excluded.indexOf(key) >= 0) continue;if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;target[key] = source[key];
        }
      }return target;
    }

    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};var target = {};var sourceKeys = Object.keys(source);var key, i;for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];if (excluded.indexOf(key) >= 0) continue;target[key] = source[key];
      }return target;
    }

    var ALIGNMENTS = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];
    var ALIGNMENTS_MAP = {
      bottom: ['tc', 'bc'],
      'bottom-left': ['tl', 'bl'],
      'bottom-right': ['tr', 'br'],
      left: ['cr', 'cl'],
      right: ['cl', 'cr'],
      top: ['bc', 'tc'],
      'top-left': ['bl', 'tl'],
      'top-right': ['br', 'tr']
    };
    var ALIGNMENTS_INVERSE_MAP = {
      bctc: 'top',
      bltl: 'top-left',
      brtr: 'top-right',
      clcr: 'right',
      crcl: 'left',
      tcbc: 'bottom',
      tlbl: 'bottom-left',
      trbr: 'bottom-right'
    };
    var initialState = {
      align: 'top',
      message: '',
      show: false
    };

    var reducer = function reducer(state, _ref) {
      var type = _ref.type,
          payload = _objectWithoutProperties(_ref, ["type"]);

      switch (type) {
        case 'align':
          return _objectSpread(_objectSpread({}, state), payload);

        case 'show':
          return _objectSpread(_objectSpread(_objectSpread({}, state), payload), {}, {
            show: true
          });

        case 'hide':
          return _objectSpread(_objectSpread({}, state), {}, {
            align: initialState.align,
            show: false
          });

        default:
          throw new TypeError();
      }
    };

    function matches(element, selectorString) {
      if (element.matches) {
        return element.matches(selectorString);
      } else if (element.msMatchesSelector) {
        return element.msMatchesSelector(selectorString);
      } else if (element.webkitMatchesSelector) {
        return element.webkitMatchesSelector(selectorString);
      } else {
        return false;
      }
    }

    function closestAncestor(node, s) {
      var ancestor = node;

      if (!document.documentElement.contains(node)) {
        return null;
      }

      do {
        if (matches(ancestor, s)) {
          return ancestor;
        }

        ancestor = ancestor.parentElement;
      } while (ancestor !== null);

      return null;
    }

    var TooltipProvider = function TooltipProvider(_ref2) {
      var _ref2$autoAlign = _ref2.autoAlign,
          autoAlign = _ref2$autoAlign === void 0 ? true : _ref2$autoAlign,
          children = _ref2.children,
          _ref2$contentRenderer = _ref2.contentRenderer,
          contentRenderer = _ref2$contentRenderer === void 0 ? function (props) {
        return props.title;
      } : _ref2$contentRenderer,
          _ref2$delay = _ref2.delay,
          delay = _ref2$delay === void 0 ? 600 : _ref2$delay;

      var _React$useReducer = _react.default.useReducer(reducer, initialState),
          _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
          _React$useReducer2$ = _React$useReducer2[0],
          align = _React$useReducer2$.align,
          _React$useReducer2$$m = _React$useReducer2$.message,
          message = _React$useReducer2$$m === void 0 ? '' : _React$useReducer2$$m,
          show = _React$useReducer2$.show,
          dispatch = _React$useReducer2[1]; // Using `any` type since TS incorrectly infers setTimeout to be from NodeJS


      var timeoutIdRef = _react.default.useRef();

      var targetRef = _react.default.useRef(null);

      var titleNodeRef = _react.default.useRef(null);

      var tooltipRef = _react.default.useRef(null);

      var handleHide = (0, _react.useCallback)(function (_ref3) {
        var target = _ref3.target;

        if (!titleNodeRef.current) {
          return;
        }

        var dataTitle = titleNodeRef.current.getAttribute('data-title');

        if (dataTitle) {
          document.removeEventListener('keyup', handleEsc, true);
          target.removeEventListener('click', handleHide);
          titleNodeRef.current.setAttribute('title', dataTitle);
          titleNodeRef.current.removeAttribute('data-title');
          titleNodeRef.current = null;
          targetRef.current = null;
          dispatch({
            type: 'hide'
          });
          clearTimeout(timeoutIdRef.current);
        }
      }, []);
      var handleEsc = (0, _react.useCallback)(function (event) {
        if (event.key === _shared.Keys.Esc) {
          event.stopImmediatePropagation();
          handleHide(event);
        }
      }, []);
      var handleShow = (0, _react.useCallback)(function (_ref4) {
        var target = _ref4.target;
        var hasTitle = target && target.hasAttribute('title');
        var titleNode = hasTitle ? target : closestAncestor(target, '[title]');
        var title = titleNode && titleNode.getAttribute('title');

        if (title) {
          titleNodeRef.current = titleNode;
          targetRef.current = target;
          document.addEventListener('keyup', handleEsc, true);
          target.addEventListener('click', handleHide);
          titleNode.setAttribute('data-title', title);
          titleNode.removeAttribute('title');
          var customDelay = titleNode.getAttribute('data-tooltip-delay');
          var newAlign = titleNode.getAttribute('data-tooltip-align');
          timeoutIdRef.current = setTimeout(function () {
            dispatch({
              align: newAlign || align,
              message: title,
              type: 'show'
            });
          }, customDelay ? Number(customDelay) : delay);
        }
      }, []);

      _react.default.useEffect(function () {
        if (titleNodeRef.current && tooltipRef.current) {
          var points = ALIGNMENTS_MAP[align || 'top'];
          var newAlignmentString = (0, _domAlign.default)(tooltipRef.current, titleNodeRef.current, {
            overflow: {
              adjustX: autoAlign,
              adjustY: autoAlign
            },
            points: points
          }).points.join('');
          var pointsString = points.join('');

          if (pointsString !== newAlignmentString) {
            dispatch({
              align: ALIGNMENTS_INVERSE_MAP[newAlignmentString],
              type: 'align'
            });
          }
        }
      }, [align, show]);

      void 0;
      return (/*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, show && /*#__PURE__*/_react.default.createElement(_shared.ClayPortal, null, /*#__PURE__*/_react.default.createElement(_Tooltip.default, {
          alignPosition: align,
          ref: tooltipRef,
          show: true
        }, contentRenderer({
          targetNode: targetRef.current,
          title: message
        }))), /*#__PURE__*/_react.default.cloneElement(children, _objectSpread(_objectSpread({}, children.props), {}, {
          onMouseOut: handleHide,
          onMouseOver: handleShow
        })))
      );
    };

    var _default = TooltipProvider;
    exports.default = _default;
  }
});
//# sourceMappingURL=TooltipProvider.js.map
"use strict";

Liferay.Loader.define("@frontend-taglib-clay$clayui/tooltip@3.4.0/lib/index", ['module', 'exports', 'require', './Tooltip', './TooltipProvider'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "ClayTooltipProvider", {
      enumerable: true,
      get: function get() {
        return _TooltipProvider.default;
      }
    });
    exports.default = void 0;

    var _Tooltip = _interopRequireDefault(require("./Tooltip"));

    var _TooltipProvider = _interopRequireDefault(require("./TooltipProvider"));

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    /**
     * SPDX-FileCopyrightText: © 2019 Liferay, Inc. <https://liferay.com>
     * SPDX-License-Identifier: BSD-3-Clause
     */
    var _default = _Tooltip.default;
    exports.default = _default;
  }
});
//# sourceMappingURL=index.js.map
'use strict';

/**
 * Geometry utility.
 */

Liferay.Loader.define("frontend-js-metal-web$metal-position@2.1.2/lib/Geometry", ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
      }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }

    var Geometry = function () {
      function Geometry() {
        _classCallCheck(this, Geometry);
      }

      _createClass(Geometry, null, [{
        key: 'intersectRect',

        /**
         * Tests if a rectangle intersects with another.
         *
         * <pre>
         *  x0y0 --------       x2y2 --------
         *      |       |           |       |
         *      -------- x1y1       -------- x3y3
         * </pre>
         *
         * Note that coordinates starts from top to down (y), left to right (x):
         *
         * <pre>
         *      ------> (x)
         *      |
         *      |
         *     (y)
         * </pre>
         *
         * @param {number} x0 Horizontal coordinate of P0.
         * @param {number} y0 Vertical coordinate of P0.
         * @param {number} x1 Horizontal coordinate of P1.
         * @param {number} y1 Vertical coordinate of P1.
         * @param {number} x2 Horizontal coordinate of P2.
         * @param {number} y2 Vertical coordinate of P2.
         * @param {number} x3 Horizontal coordinate of P3.
         * @param {number} y3 Vertical coordinate of P3.
         * @return {boolean}
         */
        value: function intersectRect(x0, y0, x1, y1, x2, y2, x3, y3) {
          return !(x2 > x1 || x3 < x0 || y2 > y1 || y3 < y0);
        }
      }]);

      return Geometry;
    }();

    exports.default = Geometry;
  }
});
//# sourceMappingURL=Geometry.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-position@2.1.2/lib/Position", ['module', 'exports', 'require', 'frontend-js-metal-web$metal', './Geometry'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _metal = require("frontend-js-metal-web$metal");

		var _metal2 = _interopRequireDefault(_metal);

		var _Geometry = require('./Geometry');

		var _Geometry2 = _interopRequireDefault(_Geometry);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		/**
   * Class with static methods responsible for doing browser position checks.
   */
		var Position = function () {
			function Position() {
				_classCallCheck(this, Position);
			}

			_createClass(Position, null, [{
				key: 'getClientHeight',

				/**
     * Gets the client height of the specified node. Scroll height is not
     * included.
     * @param {Element|Document|Window=} node
     * @return {number}
     */
				value: function getClientHeight(node) {
					return this.getClientSize_(node, 'Height');
				}

				/**
     * Gets the client height or width of the specified node. Scroll height is
     * not included.
     * @param {Element|Document|Window=} node
     * @param {string} prop `Width` or `Height` property.
     * @return {number}
     * @protected
     */

			}, {
				key: 'getClientSize_',
				value: function getClientSize_(node, prop) {
					var el = node;
					if (_metal2.default.isWindow(node)) {
						el = node.document.documentElement;
					}
					if (_metal2.default.isDocument(node)) {
						el = node.documentElement;
					}
					return el['client' + prop];
				}

				/**
     * Gets the client width of the specified node. Scroll width is not
     * included.
     * @param {Element|Document|Window=} node
     * @return {number}
     */

			}, {
				key: 'getClientWidth',
				value: function getClientWidth(node) {
					return this.getClientSize_(node, 'Width');
				}

				/**
     * Gets the region of the element, document or window.
     * @param {Element|Document|Window=} element Optional element to test.
     * @return {!DOMRect} The returned value is a simulated DOMRect object which
     *     is the union of the rectangles returned by getClientRects() for the
     *     element, i.e., the CSS border-boxes associated with the element.
     * @protected
     */

			}, {
				key: 'getDocumentRegion_',
				value: function getDocumentRegion_(element) {
					var height = this.getHeight(element);
					var width = this.getWidth(element);
					return this.makeRegion(height, height, 0, width, 0, width);
				}

				/**
     * Gets the height of the specified node. Scroll height is included.
     * @param {Element|Document|Window=} node
     * @return {number}
     */

			}, {
				key: 'getHeight',
				value: function getHeight(node) {
					return this.getSize_(node, 'Height');
				}

				/**
     * Gets the top offset position of the given node. This fixes the `offsetLeft` value of
     * nodes that were translated, which don't take that into account at all. That makes
     * the calculation more expensive though, so if you don't want that to be considered
     * either pass `ignoreTransform` as true or call `offsetLeft` directly on the node.
     * @param {!Element} node
     * @param {boolean=} ignoreTransform When set to true will ignore transform css
     *   when calculating the position. Defaults to false.
     * @return {number}
     */

			}, {
				key: 'getOffsetLeft',
				value: function getOffsetLeft(node, ignoreTransform) {
					return node.offsetLeft + (ignoreTransform ? 0 : Position.getTranslation(node).left);
				}

				/**
     * Gets the top offset position of the given node. This fixes the `offsetTop` value of
     * nodes that were translated, which don't take that into account at all. That makes
     * the calculation more expensive though, so if you don't want that to be considered
     * either pass `ignoreTransform` as true or call `offsetTop` directly on the node.
     * @param {!Element} node
     * @param {boolean=} ignoreTransform When set to true will ignore transform css
     *   when calculating the position. Defaults to false.
     * @return {number}
     */

			}, {
				key: 'getOffsetTop',
				value: function getOffsetTop(node, ignoreTransform) {
					return node.offsetTop + (ignoreTransform ? 0 : Position.getTranslation(node).top);
				}

				/**
     * Gets the size of an element and its position relative to the viewport.
     * @param {!Document|Element|Window} node
     * @param {boolean=} includeScroll Flag indicating if the document scroll
     *   position should be considered in the element's region coordinates. Defaults
     *   to false.
     * @return {!DOMRect} The returned value is a DOMRect object which is the
     *     union of the rectangles returned by getClientRects() for the element,
     *     i.e., the CSS border-boxes associated with the element.
     */

			}, {
				key: 'getRegion',
				value: function getRegion(node, includeScroll) {
					if (_metal2.default.isDocument(node) || _metal2.default.isWindow(node)) {
						return this.getDocumentRegion_(node);
					}
					return this.makeRegionFromBoundingRect_(node.getBoundingClientRect(), includeScroll);
				}

				/**
     * Gets the scroll left position of the specified node.
     * @param {Element|Document|Window=} node
     * @return {number}
     */

			}, {
				key: 'getScrollLeft',
				value: function getScrollLeft(node) {
					if (_metal2.default.isWindow(node)) {
						return node.pageXOffset;
					}
					if (_metal2.default.isDocument(node)) {
						return node.defaultView.pageXOffset;
					}
					return node.scrollLeft;
				}

				/**
     * Gets the scroll top position of the specified node.
     * @param {Element|Document|Window=} node
     * @return {number}
     */

			}, {
				key: 'getScrollTop',
				value: function getScrollTop(node) {
					if (_metal2.default.isWindow(node)) {
						return node.pageYOffset;
					}
					if (_metal2.default.isDocument(node)) {
						return node.defaultView.pageYOffset;
					}
					return node.scrollTop;
				}

				/**
     * Gets the height or width of the specified node. Scroll height is
     * included.
     * @param {Element|Document|Window=} node
     * @param {string} prop `Width` or `Height` property.
     * @return {number}
     * @protected
     */

			}, {
				key: 'getSize_',
				value: function getSize_(node, prop) {
					if (_metal2.default.isWindow(node)) {
						return this.getClientSize_(node, prop);
					}
					if (_metal2.default.isDocument(node)) {
						var docEl = node.documentElement;
						return Math.max(node.body['scroll' + prop], docEl['scroll' + prop], node.body['offset' + prop], docEl['offset' + prop], docEl['client' + prop]);
					}
					return Math.max(node['client' + prop], node['scroll' + prop], node['offset' + prop]);
				}

				/**
     * Gets the transform matrix values for the given node.
     * @param {!Element} node
     * @return {Array<number>}
     */

			}, {
				key: 'getTransformMatrixValues',
				value: function getTransformMatrixValues(node) {
					var style = getComputedStyle(node);
					var transform = style.msTransform || style.transform || style.webkitTransform || style.mozTransform;
					if (transform !== 'none') {
						var values = [];
						var regex = /([\d-\.\s]+)/g;
						var matches = regex.exec(transform);
						while (matches) {
							values.push(matches[1]);
							matches = regex.exec(transform);
						}
						return values;
					}
				}

				/**
     * Gets the number of translated pixels for the given node, for both the top and
     * left positions.
     * @param {!Element} node
     * @return {number}
     */

			}, {
				key: 'getTranslation',
				value: function getTranslation(node) {
					var values = Position.getTransformMatrixValues(node);
					var translation = {
						left: 0,
						top: 0
					};
					if (values) {
						translation.left = parseFloat(values.length === 6 ? values[4] : values[13]);
						translation.top = parseFloat(values.length === 6 ? values[5] : values[14]);
					}
					return translation;
				}

				/**
     * Gets the width of the specified node. Scroll width is included.
     * @param {Element|Document|Window=} node
     * @return {number}
     */

			}, {
				key: 'getWidth',
				value: function getWidth(node) {
					return this.getSize_(node, 'Width');
				}

				/**
     * Tests if a region intersects with another.
     * @param {DOMRect} r1
     * @param {DOMRect} r2
     * @return {boolean}
     */

			}, {
				key: 'intersectRegion',
				value: function intersectRegion(r1, r2) {
					return _Geometry2.default.intersectRect(r1.top, r1.left, r1.bottom, r1.right, r2.top, r2.left, r2.bottom, r2.right);
				}

				/**
     * Tests if a region is inside another.
     * @param {DOMRect} r1
     * @param {DOMRect} r2
     * @return {boolean}
     */

			}, {
				key: 'insideRegion',
				value: function insideRegion(r1, r2) {
					return r2.top >= r1.top && r2.bottom <= r1.bottom && r2.right <= r1.right && r2.left >= r1.left;
				}

				/**
     * Tests if a region is inside viewport region.
     * @param {DOMRect} region
     * @return {boolean}
     */

			}, {
				key: 'insideViewport',
				value: function insideViewport(region) {
					return this.insideRegion(this.getRegion(window), region);
				}

				/**
     * Computes the intersection region between two regions.
     * @param {DOMRect} r1
     * @param {DOMRect} r2
     * @return {?DOMRect} Intersection region or null if regions doesn't
     *     intersects.
     */

			}, {
				key: 'intersection',
				value: function intersection(r1, r2) {
					if (!this.intersectRegion(r1, r2)) {
						return null;
					}
					var bottom = Math.min(r1.bottom, r2.bottom);
					var right = Math.min(r1.right, r2.right);
					var left = Math.max(r1.left, r2.left);
					var top = Math.max(r1.top, r2.top);
					return this.makeRegion(bottom, bottom - top, left, right, top, right - left);
				}

				/**
     * Makes a region object. It's a writable version of DOMRect.
     * @param {number} bottom
     * @param {number} height
     * @param {number} left
     * @param {number} right
     * @param {number} top
     * @param {number} width
     * @return {!DOMRect} The returned value is a DOMRect object which is the
     *     union of the rectangles returned by getClientRects() for the element,
     *     i.e., the CSS border-boxes associated with the element.
     */

			}, {
				key: 'makeRegion',
				value: function makeRegion(bottom, height, left, right, top, width) {
					return {
						bottom: bottom,
						height: height,
						left: left,
						right: right,
						top: top,
						width: width
					};
				}

				/**
     * Makes a region from a DOMRect result from `getBoundingClientRect`.
     * @param  {!DOMRect} rect The returned value is a DOMRect object which is the
     *     union of the rectangles returned by getClientRects() for the element,
     *     i.e., the CSS border-boxes associated with the element.
     * @param {boolean=} includeScroll Flag indicating if the document scroll
     *   position should be considered in the element's region coordinates. Defaults
     *   to false.
     * @return {DOMRect} Writable version of DOMRect.
     * @protected
     */

			}, {
				key: 'makeRegionFromBoundingRect_',
				value: function makeRegionFromBoundingRect_(rect, includeScroll) {
					var deltaX = includeScroll ? Position.getScrollLeft(document) : 0;
					var deltaY = includeScroll ? Position.getScrollTop(document) : 0;
					return this.makeRegion(rect.bottom + deltaY, rect.height, rect.left + deltaX, rect.right + deltaX, rect.top + deltaY, rect.width);
				}

				/**
     * Checks if the given point coordinates are inside a region.
     * @param {number} x
     * @param {number} y
     * @param {!Object} region
     * @return {boolean}
     */

			}, {
				key: 'pointInsideRegion',
				value: function pointInsideRegion(x, y, region) {
					return Position.insideRegion(region, Position.makeRegion(y, 0, x, x, y, 0));
				}
			}]);

			return Position;
		}();

		exports.default = Position;
	}
});
//# sourceMappingURL=Position.js.map
'use strict';

Liferay.Loader.define("frontend-js-metal-web$metal-position@2.1.2/lib/Align", ['module', 'exports', 'require', './Position'], function (module, exports, require) {
	var define = undefined;
	var global = window;
	{
		Object.defineProperty(exports, "__esModule", {
			value: true
		});

		var _createClass = function () {
			function defineProperties(target, props) {
				for (var i = 0; i < props.length; i++) {
					var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
				}
			}return function (Constructor, protoProps, staticProps) {
				if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
			};
		}();

		var _Position = require('./Position');

		var _Position2 = _interopRequireDefault(_Position);

		function _interopRequireDefault(obj) {
			return obj && obj.__esModule ? obj : { default: obj };
		}

		function _classCallCheck(instance, Constructor) {
			if (!(instance instanceof Constructor)) {
				throw new TypeError("Cannot call a class as a function");
			}
		}

		/**
   * Align utility. Computes region or best region to align an element with
   * another. Regions are relative to viewport, make sure to use element with
   * position fixed, or position absolute when the element first positioned
   * parent is the body element.
   */
		var Align = function () {
			function Align() {
				_classCallCheck(this, Align);
			}

			_createClass(Align, null, [{
				key: 'align',

				/**
     * Aligns the element with the best region around alignElement. The best
     * region is defined by clockwise rotation starting from the specified
     * `position`. The element is always aligned in the middle of alignElement
     * axis.
     * @param {!Element} element Element to be aligned.
     * @param {!Element} alignElement Element to align with.
     * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} position
     *     The initial position to try. Options `Align.Top`, `Align.Right`,
     *     `Align.Bottom`, `Align.Left`.
     * @param {boolean} autoBestAlign Option to suggest or not the best region
     *      to align.
     * @return {string} The final chosen position for the aligned element.
     * @static
     */
				value: function align(element, alignElement, position) {
					var autoBestAlign = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;

					var bestRegion = void 0;

					if (autoBestAlign) {
						var suggestion = this.suggestAlignBestRegion(element, alignElement, position);
						position = suggestion.position;
						bestRegion = suggestion.region;
					} else {
						bestRegion = this.getAlignRegion(element, alignElement, position);
					}

					var computedStyle = window.getComputedStyle(element, null);
					if (computedStyle.getPropertyValue('position') !== 'fixed') {
						bestRegion.top += window.pageYOffset;
						bestRegion.left += window.pageXOffset;

						var offsetParent = element;
						while (offsetParent = offsetParent.offsetParent) {
							bestRegion.top -= _Position2.default.getOffsetTop(offsetParent);
							bestRegion.left -= _Position2.default.getOffsetLeft(offsetParent);
						}
					}

					element.style.top = bestRegion.top + 'px';
					element.style.left = bestRegion.left + 'px';
					return position;
				}

				/**
     * Returns the best region to align element with alignElement. This is similar
     * to `Align.suggestAlignBestRegion`, but it only returns the region information,
     * while `Align.suggestAlignBestRegion` also returns the chosen position.
     * @param {!Element} element Element to be aligned.
     * @param {!Element} alignElement Element to align with.
     * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} position
     *     The initial position to try. Options `Align.Top`, `Align.Right`,
     *     `Align.Bottom`, `Align.Left`.
     * @return {DOMRect} Best region to align element.
     * @static
     */

			}, {
				key: 'getAlignBestRegion',
				value: function getAlignBestRegion(element, alignElement, position) {
					return Align.suggestAlignBestRegion(element, alignElement, position).region;
				}

				/**
     * Returns the region to align element with alignElement. The element is
     * always aligned in the middle of alignElement axis.
     * @param {!Element} element Element to be aligned.
     * @param {!Element} alignElement Element to align with.
     * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} position
     *     The position to align. Options `Align.Top`, `Align.Right`,
     *     `Align.Bottom`, `Align.Left`.
     * @return {DOMRect} Region to align element.
     * @static
     */

			}, {
				key: 'getAlignRegion',
				value: function getAlignRegion(element, alignElement, position) {
					var r1 = _Position2.default.getRegion(alignElement);
					var r2 = _Position2.default.getRegion(element);
					var top = 0;
					var left = 0;

					switch (position) {
						case Align.TopCenter:
							top = r1.top - r2.height;
							left = r1.left + r1.width / 2 - r2.width / 2;
							break;
						case Align.RightCenter:
							top = r1.top + r1.height / 2 - r2.height / 2;
							left = r1.left + r1.width;
							break;
						case Align.BottomCenter:
							top = r1.bottom;
							left = r1.left + r1.width / 2 - r2.width / 2;
							break;
						case Align.LeftCenter:
							top = r1.top + r1.height / 2 - r2.height / 2;
							left = r1.left - r2.width;
							break;
						case Align.TopRight:
							top = r1.top - r2.height;
							left = r1.right - r2.width;
							break;
						case Align.BottomRight:
							top = r1.bottom;
							left = r1.right - r2.width;
							break;
						case Align.BottomLeft:
							top = r1.bottom;
							left = r1.left;
							break;
						case Align.TopLeft:
							top = r1.top - r2.height;
							left = r1.left;
							break;
					}

					return {
						bottom: top + r2.height,
						height: r2.height,
						left: left,
						right: left + r2.width,
						top: top,
						width: r2.width
					};
				}

				/**
     * Checks if specified value is a valid position. Options `Align.Top`,
     *     `Align.Right`, `Align.Bottom`, `Align.Left`.
     * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} val
     * @return {boolean} Returns true if value is a valid position.
     * @static
     */

			}, {
				key: 'isValidPosition',
				value: function isValidPosition(val) {
					return 0 <= val && val <= 8;
				}

				/**
     * Looks for the best region for aligning the given element. The best
     * region is defined by clockwise rotation starting from the specified
     * `position`. The element is always aligned in the middle of alignElement
     * axis.
     * @param {!Element} element Element to be aligned.
     * @param {!Element} alignElement Element to align with.
     * @param {Align.Top|Align.Right|Align.Bottom|Align.Left} position
     *     The initial position to try. Options `Align.Top`, `Align.Right`,
     *     `Align.Bottom`, `Align.Left`.
     * @return {{position: string, region: DOMRect}} Best region to align element.
     * @static
     */

			}, {
				key: 'suggestAlignBestRegion',
				value: function suggestAlignBestRegion(element, alignElement, position) {
					var bestArea = 0;
					var bestPosition = position;
					var bestRegion = this.getAlignRegion(element, alignElement, bestPosition);
					var tryPosition = bestPosition;
					var tryRegion = bestRegion;
					var viewportRegion = _Position2.default.getRegion(window);

					for (var i = 0; i < 8;) {
						if (_Position2.default.intersectRegion(viewportRegion, tryRegion)) {
							var visibleRegion = _Position2.default.intersection(viewportRegion, tryRegion);
							var area = visibleRegion.width * visibleRegion.height;
							if (area > bestArea) {
								bestArea = area;
								bestRegion = tryRegion;
								bestPosition = tryPosition;
							}
							if (_Position2.default.insideViewport(tryRegion)) {
								break;
							}
						}
						tryPosition = (position + ++i) % 8;
						tryRegion = this.getAlignRegion(element, alignElement, tryPosition);
					}

					return {
						position: bestPosition,
						region: bestRegion
					};
				}
			}]);

			return Align;
		}();

		/**
   * Constants that represent the supported positions for `Align`.
   * @type {number}
   * @static
   */

		Align.TopCenter = 0;
		Align.TopRight = 1;
		Align.RightCenter = 2;
		Align.BottomRight = 3;
		Align.BottomCenter = 4;
		Align.BottomLeft = 5;
		Align.LeftCenter = 6;
		Align.TopLeft = 7;

		/**
   * Aliases for position constants.
   * @type {number}
   * @static
   */
		Align.Top = Align.TopCenter;
		Align.Right = Align.RightCenter;
		Align.Bottom = Align.BottomCenter;
		Align.Left = Align.LeftCenter;

		exports.default = Align;
	}
});
//# sourceMappingURL=Align.js.map
'use strict';

Liferay.Loader.define('frontend-js-metal-web$metal-position@2.1.2/lib/all/position', ['module', 'exports', 'require', '../Align', '../Geometry', '../Position'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.Position = exports.Geometry = exports.Align = undefined;

    var _Align = require('../Align');

    var _Align2 = _interopRequireDefault(_Align);

    var _Geometry = require('../Geometry');

    var _Geometry2 = _interopRequireDefault(_Geometry);

    var _Position = require('../Position');

    var _Position2 = _interopRequireDefault(_Position);

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    exports.default = _Position2.default;
    exports.Align = _Align2.default;
    exports.Geometry = _Geometry2.default;
    exports.Position = _Position2.default;
  }
});
//# sourceMappingURL=position.js.map
Liferay.Loader.define('frontend-js-tooltip-support-web@3.0.4/reducer', ['module', 'exports', 'require'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = reducer;
    exports.STATES = void 0;

    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);if (enumerableOnly) symbols = symbols.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });keys.push.apply(keys, symbols);
      }return keys;
    }

    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};if (i % 2) {
          ownKeys(Object(source), true).forEach(function (key) {
            _defineProperty(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(Object(source)).forEach(function (key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }return target;
    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }return obj;
    }

    /**
     * Copyright (c) 2000-present Liferay, Inc. All rights reserved.
     *
     * This library is free software; you can redistribute it and/or modify it under
     * the terms of the GNU Lesser General Public License as published by the Free
     * Software Foundation; either version 2.1 of the License, or (at your option)
     * any later version.
     *
     * This library is distributed in the hope that it will be useful, but WITHOUT
     * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
     * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more
     * details.
     */
    var STATES = {
      IDLE: {
        show: false
      },
      SHOW: {
        show: true
      },
      WAIT_HIDE: {
        show: true
      },
      WAIT_RESHOW: {
        show: true
      },
      WAIT_SHOW: {
        show: false
      }
    };
    exports.STATES = STATES;

    function reducer(state, action) {
      switch (action.type) {
        case 'show':
          if (state.current === STATES.IDLE) {
            return _objectSpread(_objectSpread({}, state), {}, {
              current: STATES.WAIT_SHOW,
              target: action.target,
              timestamp: Date.now()
            });
          } else if (state.current === STATES.WAIT_SHOW) {
            return _objectSpread(_objectSpread({}, state), {}, {
              target: action.target,
              timestamp: Date.now()
            });
          } else if (state.current === STATES.WAIT_RESHOW) {
            return _objectSpread(_objectSpread({}, state), {}, {
              nextTarget: action.target,
              timestamp: Date.now()
            });
          } else if (state.current === STATES.WAIT_HIDE) {
            return _objectSpread(_objectSpread({}, state), {}, {
              current: STATES.WAIT_RESHOW,
              nextTarget: action.target
            });
          } else {
            return _objectSpread(_objectSpread({}, state), {}, {
              timestamp: Date.now()
            });
          }

        case 'hideDelayCompleted':
          if (state.current === STATES.WAIT_HIDE) {
            return {
              current: STATES.IDLE
            };
          }

          break;

        case 'showDelayCompleted':
          if (state.current === STATES.WAIT_SHOW) {
            return _objectSpread(_objectSpread({}, state), {}, {
              current: STATES.SHOW
            });
          } else if (state.current === STATES.WAIT_RESHOW) {
            return _objectSpread(_objectSpread({}, state), {}, {
              current: STATES.SHOW,
              target: state.nextTarget
            });
          }

          break;

        case 'hide':
          if (state.current === STATES.WAIT_SHOW) {
            return {
              current: STATES.IDLE
            };
          } else if (state.current === STATES.SHOW || state.current === STATES.WAIT_RESHOW) {
            return _objectSpread(_objectSpread({}, state), {}, {
              current: STATES.WAIT_HIDE,
              timestamp: Date.now()
            });
          }

          break;

        default:
          return state;
      }

      return state;
    }
    //# sourceMappingURL=reducer.js.map
  }
});
//# sourceMappingURL=reducer.js.map
Liferay.Loader.define("frontend-js-tooltip-support-web@3.0.4/index", ['module', 'exports', 'require', '@frontend-taglib-clay$clayui/tooltip', 'frontend-js-react-web', 'frontend-js-metal-web$metal-dom', 'frontend-js-metal-web$metal-position', 'frontend-js-react-web$react', './reducer'], function (module, exports, require) {
  var define = undefined;
  var global = window;
  {
    function _typeof(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof = function _typeof(obj) {
          return typeof obj;
        };
      } else {
        _typeof = function _typeof(obj) {
          return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
        };
      }return _typeof(obj);
    }

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;

    var _tooltip = _interopRequireDefault(require("@frontend-taglib-clay$clayui/tooltip"));

    var _frontendJsReactWeb = require("frontend-js-react-web");

    var _metalDom = _interopRequireDefault(require("frontend-js-metal-web$metal-dom"));

    var _metalPosition = require("frontend-js-metal-web$metal-position");

    var _react = _interopRequireWildcard(require("frontend-js-react-web$react"));

    var _reducer = _interopRequireWildcard(require("./reducer"));

    function _getRequireWildcardCache() {
      if (typeof WeakMap !== "function") return null;var cache = new WeakMap();_getRequireWildcardCache = function _getRequireWildcardCache() {
        return cache;
      };return cache;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      }if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
        return { default: obj };
      }var cache = _getRequireWildcardCache();if (cache && cache.has(obj)) {
        return cache.get(obj);
      }var newObj = {};var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }newObj.default = obj;if (cache) {
        cache.set(obj, newObj);
      }return newObj;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }

    function _toConsumableArray(arr) {
      return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance");
    }

    function _iterableToArray(iter) {
      if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    function _arrayWithoutHoles(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
          arr2[i] = arr[i];
        }return arr2;
      }
    }

    function _slicedToArray(arr, i) {
      return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    function _iterableToArrayLimit(arr, i) {
      if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
        return;
      }var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;_e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }return _arr;
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    var ALIGN_POSITIONS = ['top-right', 'top', 'top-left', 'bottom-right', 'bottom', 'bottom-left', 'left', 'right'];
    var SELECTOR_TOOLTIP = '.tooltip[role="tooltip"]';
    var SELECTOR_TRIGGER = "\n\t.lfr-portal-tooltip,\n\t.manage-collaborators-dialog .lexicon-icon[data-title]:not(.lfr-portal-tooltip),\n\t.manage-collaborators-dialog .lexicon-icon[title]:not(.lfr-portal-tooltip),\n\t.manage-collaborators-dialog [data-restore-title],\n\t.management-bar [data-title]:not(.lfr-portal-tooltip),\n\t.management-bar [title]:not(.lfr-portal-tooltip),\n\t.management-bar [data-restore-title],\n\t.preview-toolbar-container [data-title]:not(.lfr-portal-tooltip),\n\t.preview-toolbar-container [title]:not(.lfr-portal-tooltip),\n\t.preview-tooltbar-containter [data-restore-title],\n\t.progress-container[data-title],\n\t.redirect-entries span[data-title],\n\t.source-editor__fixed-text__help[data-title],\n\t.upper-tbar [data-title]:not(.lfr-portal-tooltip),\n\t.upper-tbar [title]:not(.lfr-portal-tooltip),\n\t.upper-tbar [data-restore-title]\n";
    var TRIGGER_HIDE_EVENTS = ['mouseleave', 'mouseup', 'MSPointerUp', 'pointerup', 'touchend'];
    var TRIGGER_SHOW_EVENTS = ['mouseenter', 'mouseup', 'MSPointerDown', 'pointerdown', 'touchstart'];
    var DEFAULT_TOOLTIP_CONTAINER_ID = 'tooltipContainer';

    var getDefaultTooltipContainer = function getDefaultTooltipContainer() {
      var container = document.getElementById(DEFAULT_TOOLTIP_CONTAINER_ID);

      if (!container) {
        container = document.createElement('div');
        container.id = DEFAULT_TOOLTIP_CONTAINER_ID;
        document.body.appendChild(container);
      }

      return container;
    };

    var TooltipProvider = function TooltipProvider() {
      var delay = (0, _frontendJsReactWeb.useTimeout)();

      var _useReducer = (0, _react.useReducer)(_reducer.default, {
        current: _reducer.STATES.IDLE
      }),
          _useReducer2 = _slicedToArray(_useReducer, 2),
          state = _useReducer2[0],
          dispatch = _useReducer2[1];

      var tooltipRef = (0, _react.useRef)(null);

      var _useState = (0, _react.useState)(0),
          _useState2 = _slicedToArray(_useState, 2),
          alignment = _useState2[0],
          setAlignment = _useState2[1];

      (0, _react.useEffect)(function () {
        var dispose;

        if (state.current === _reducer.STATES.WAIT_SHOW) {
          dispose = delay(function () {
            return dispatch({
              type: 'showDelayCompleted'
            });
          }, 500);
        } else if (state.current === _reducer.STATES.WAIT_HIDE) {
          dispose = delay(function () {
            return dispatch({
              type: 'hideDelayCompleted'
            });
          }, 100);
        } else if (state.current === _reducer.STATES.WAIT_RESHOW) {
          dispose = delay(function () {
            return dispatch({
              type: 'showDelayCompleted'
            });
          }, 100);
        }

        return dispose;
      }, [delay, state]);

      var saveTitle = function saveTitle(element) {
        if (element) {
          var title = element.getAttribute('title');

          if (title) {
            element.setAttribute('data-restore-title', title);
            element.removeAttribute('title');
          } else if (element.tagName === 'svg') {
            var titleTag = element.querySelector('title');

            if (titleTag) {
              element.setAttribute('data-restore-title', titleTag.innerHTML);
              titleTag.remove();
            }
          }
        }
      };

      var restoreTitle = function restoreTitle(element) {
        if (element) {
          var title = element.getAttribute('data-restore-title');

          if (title) {
            if (element.tagName === 'svg') {
              var titleTag = document.createElement('title');
              titleTag.innerHTML = title;
              element.appendChild(titleTag);
            } else {
              element.setAttribute('title', title);
            }

            element.removeAttribute('data-restore-title');
          }
        }
      };

      (0, _react.useEffect)(function () {
        var TRIGGER_SHOW_HANDLES = TRIGGER_SHOW_EVENTS.map(function (eventName) {
          return _metalDom.default.delegate(document.body, eventName, SELECTOR_TRIGGER, function (event) {
            saveTitle(event.delegateTarget);
            dispatch({
              target: event.delegateTarget,
              type: 'show'
            });
          });
        });
        var TRIGGER_HIDE_HANDLES = TRIGGER_HIDE_EVENTS.map(function (eventName) {
          return _metalDom.default.delegate(document.body, eventName, SELECTOR_TRIGGER, function () {
            dispatch({
              type: 'hide'
            });
            restoreTitle(state.target);
          });
        });

        var TOOLTIP_ENTER = _metalDom.default.delegate(document.body, 'mouseenter', SELECTOR_TOOLTIP, function () {
          return dispatch({
            target: state.target,
            type: 'show'
          });
        });

        var TOOLTIP_LEAVE = _metalDom.default.delegate(document.body, 'mouseleave', SELECTOR_TOOLTIP, function () {
          return dispatch({
            type: 'hide'
          });
        });

        return function () {
          [TOOLTIP_ENTER, TOOLTIP_LEAVE].concat(_toConsumableArray(TRIGGER_HIDE_HANDLES), _toConsumableArray(TRIGGER_SHOW_HANDLES)).forEach(function (handle) {
            return handle.dispose();
          });
        };
      }, [state]);
      (0, _react.useLayoutEffect)(function () {
        if (state.target && tooltipRef.current) {
          setAlignment(_metalPosition.Align.align(tooltipRef.current, state.target, _metalPosition.Align.BottomCenter));
        }
      }, [state.target]);
      return state.target ? /*#__PURE__*/_react.default.createElement(_tooltip.default, {
        alignPosition: ALIGN_POSITIONS[alignment],
        ref: tooltipRef,
        show: state.current.show
      }, /*#__PURE__*/_react.default.createElement("div", {
        dangerouslySetInnerHTML: {
          __html: state.target.title || state.target.dataset.restoreTitle || state.target.dataset.title
        }
      })) : null;
    };

    var _default = function _default() {
      (0, _frontendJsReactWeb.render)( /*#__PURE__*/_react.default.createElement(TooltipProvider, null), {}, getDefaultTooltipContainer());
    };

    exports.default = _default;
    //# sourceMappingURL=index.js.map
  }
});
//# sourceMappingURL=index.js.map
